---
layout: post
category: React+NodeJS
thumbnail: reactNode.jpg
tags: [React, NodeJS]
typora-copy-images-to: assets\images
typora-root-url: ./
---

이번에 react를 공부하는데 지난번에 만들어놨던 Frontend template을 React로 만들기로 했다. 그러나 이 작업이 생각보다 너무 빨리 끝나서 이왕 하는거 전에 만들어놨던 Frontend template에 서버까지 씌워서 쇼핑몰로 만들기로 했다.

전에 커뮤니티를 만들어본 적이 있어서 틀은 생각보다 금방 만들것 같고, 추가로 관리자 페이지, 사용자가 글을 쓸 때 html태그를 조작하는 것 등을 같이 공부할 예정이다.

# React란?

React는 JS로 UI를 만들기 위해 페이스북에서 만든 프레임워크이다. 

컴포넌트 단위로 UI를 관리하며, 각 컴포넌트는 JSX라는 특별한 표현식과 state, props라는 속성을 통해 만들어진다.

또한 가상 DOM기능을 도입해서 가상 DOM과 실제 DOM이 다를때만 실제 DOM을 업데이트하는 효과적인 방법을 도입했다.  

React하면 보통 SPA(single page application)과 관련이 되는데, SPA란 서버에서 모든 페이지를 한번에 받아와 두고, 페이지를 이동할 때 새 페이지를 요청하지 않고 필요한 데이터만 받아와 클라이언트에서 랜더링하는 방식을 만한다.

React를 사용하면 SPA방식으로 웹 애플리케이션을 만들 수 있다.





# React 시작하기

React의 공식 문서에서 친절히 React 스타터들을 위한 자습서를 제공한다.

[자습서](https://ko.reactjs.org/tutorial/tutorial.html)

이 예제를 따라 진행하면 React가 어떤식으로 작동하는지 감을 잡을 수 있다.



React개발을 위해서는 세팅이 한데, 이 세팅을 바로 해주는 패키지가 있다. 

```shell
npx create-react-app [폴더명]
```

설치가 완료되면

```shell
cd [폴더명]
npm start
```

이 명령어를 처주면 아래 문장과 함께 웹페이지가 하나 띄워질거다(시간이 좀 걸린다). 또한 localhost:3000으로 접속해도 접속이 된다.

![화면 캡처 2021-04-21 095300](/assets/images/화면 캡처 2021-04-21 095300.png)

이제 새로 만들어진 폴더 위에서 React로 개발을 하면 된다.



# 컴포넌트

react의 기본 구성 단위인 Component는 생명주기(Lifecycle), Props, State를 가진다.

Component는 클래스, 함수 2가지 방법으로 구현할 수 있는데, 함수로 구현하는 방법이 좀 더 최신의 방법이다.



## props

props는 컴포넌트 생성시에 전달해주는 데이터. 상위 컴포넌트에서 하위 컴포넌트로 값을 전달할 때 사용한다.

## state

컴포넌트 내에서 변수처럼 관리하는 js 객체이다.

## Life Cycle

React Component들은 마운트, 업데이트, 마운트 해제등의 생명주기를 갖는다. 마운트란 Component instance가 DOM에 삽입되는 것을 말한다. 각 생명주기마다 아래 함수들이 순서대로 호출된다.

- 마운트
  1. constructor()
  2. static getDerivedStateFromProps()
  3. render()
  4. componentDidMount()

- 업데이트

  1. static getDerivedStateFromProps()
  2. shouldComponentUpdate()
  3. render()
  4. getSnapshotBeforeUpdate()
  5.  componentDidUpdate(

  

- 마운트 해제

  1. componentWillUnmount()

참고로 함수형 컴포넌트에선 위와같은 메소드들을 사용할 수 없기 때문에, hook이라는 특별한 기능을 사용한다.



## Class Component

```jsx
import React from 'react'

class Hello extends React.Component{
    render(){
        return(
            <div>Hello World {this.props.name}</div>
        )
    }
}
```

먼저, 클래스로 Component를 만드는 방법을 알아보자.  React.Component를 상속받는 class를 통해 Component class를 만들 수 있다.

render()은 React.Component의 하위 클래스에서 꼭 정의해야 하는 메서드이다. Component가 DOM에 삽입될 때 호출되며, React element를 반환한다.

return에서 반환하는 문장은  JSX라는 표현식인데, React element를 만들때 사용된다. 자세한 내용은 아래 링크를 참조하면 된다.

[jsx](https://ko.reactjs.org/docs/introducing-jsx.html)



### Class Component - props

위에서 {this.props.name} 부분은 전달된 props의 name을 저 자리에 표시해달라는 표현이다.

당연히 이를 사용하기 위해서는 Hello Component를 생성할 때, props에 name값을 넣어줘야 한다.

```jsx
import React from 'react'
import ReactDom from 'react-dom'

class Hello extends React.Component{
    render(){
        return(
            <div>Hello World {this.props.name}</div>
        )
    }
}

ReactDom.render(
    <Hello name="mingwan"/>, // props전달
    document.getElementById('root')
);
```



### Class Component - state

state를 사용하기 위해서는 초기화가 필수이다. 생성자 constructor()는 this.state를 할당할 수 있는 유일한 곳이고, 다른 부분에서 state를 변경하려면 setState를 사용해야한다.

```jsx
import React from 'react'
import ReactDom from 'react-dom'

class Hello extends React.Component{
    // state초기화
    constructor(props){ 
        super(props);
        this.state = {count : 0};
    }
    
    render(){
        return(
            <div>Hello {this.props.name} {this.state.count}</div>
        )
    }
}

ReactDom.render(
    <Hello name="mingwan"/>, // props전달
    document.getElementById('root')
);
```

생성자에서 super(props)를 호출하는 이유는 이렇게 하지 않으면 this.props가 생성자 내에서 정의되지 않아 버그가 발생할 수 있기 때문이다.

state까지 알았다면 setState함수를 실행해 볼 필요가 있다. 처음에 말했듯 React는 가상 Dom이라는 것이 존재하는데, setState함수는 Component를 리렌더링해서, DOM을 변경시킬 수 있게 해준다.

즉, setState를 호출하면 생명주기의 update과정중 state update에 관한 함수들이 실행된다.

```jsx
import React from 'react'
import ReactDom from 'react-dom'

class Hello extends React.Component{
    // state초기화
    constructor(props){ 
        super(props);
        this.state = {count : 0};
        this.onClck = this.onClick.bind(this);
    }
    
    onClick(){
        this.setState({count : this.state.count + 1});
    }
    
    render(){
        return(
            <button onClick={this.onClick}>Hello {this.props.name}, {this.state.count}</button>
        )
    }
}

ReactDom.render(
    <Hello name="mingwan"/>, // props전달
    document.getElementById('root')
);
```

참고로 constructor에서는 setState를 호출하면 안된다.



## function Component

```jsx
function Hello(props){
    return <div>Hello World {props.name}</div>
}
```

함수형 Component에서는 위와같이 render()도 필요하지 않고, this도 사용하지 않는다. js의 복잡한 this를 사용하지 않아도 되는것이 function Component의 큰 장점이다.



### function component - state

원래 function Component는 state조작이 필요없는 경우 간단히 만들어 사용했지만, hook이라는 것이 등장하면서 function component에서도 useState로 state관리가 가능해졌다.

```jsx
import React, { useState } from 'react';

function Hello(props){
    const [count, setCount] = useState(0);
    
    return <div>Hello {props.name} {count}</div>
}
```

useState함수는 state값과, 값을 업데이트하는 함수를 반환한다. 인자로 초기값을 받는데, 위 예제의 경우 count가 0으로 초기화되고, setCount를 통해 count state를 조작할 수 있다.



### function Component - life cycle

function Component에서는 effect hook을 이용해 life cycle을 관리한다. 

```jsx
import React, { useState } from 'react';

function Hello(props){
    const [count, setCount] = useState(0);
    
    useEffect(() => {
        document.title = `You clicked ${count} times`;  //componentDidMount
        //componentWillUnmount, 없어도 됨
        return ()=>{
            setCount(count-1);
        }
    }, []); //componentDidUpdate
    
    return <div>Hello {props.name} {count}</div>
}
```

useEffect는 인자로 함수 하나와 deps라 불리는 배열을 하나 받는다.

useEffect의 동작은 claen-up함수와 deps에 의해 변동된다.

clean up 함수는 use effect의 첫번째 인자로 전달한 함수에서 return 하는 함수를 뜻한다. clean up 함수가 정의되어 있다면, clean-up함수의 내용이 unmount직전, update직전에 실행된다. 

deps에 특정 변수를 넣으면, 컴포넌트가 mount될 때와 변수값이 update될 때 useEffect가 실행된다. 

deps에 빈 배열을 넣으면, 컴포넌트가 처음 렌더링 될 때만 useEffect가 실행된다.

deps위치에 배열을 전달하지 않으면 mount시와, 모든 update에 대해 useEffect가 실행된다.



# 끝









