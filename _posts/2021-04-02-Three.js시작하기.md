---
layout: post
category: WebGL
thumbnail: WebGL.png
tags: [blog, jekyll, html, css, SEO, github pages]
typora-copy-images-to: github blog\beming-dev.github.io\assets\images
typora-root-url: github blog\beming-dev.github.io
---

사실은 three.js를 하기 전에 WebGL로 정육면체까지 만들고 싶었는데 아래 글을 읽다가 포기했다..

[webglfundamentals](https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-orthographic.html)

사실 또 하려면 못할것까진 없지만 애초에 WebGL은 three.js를 하기 전에 기초만 떼기 위해 한거라서 시간을 너무 많이 투자하긴 아깝고, 이미 three.js로 정육면체를 그리는게 얼마나 편한지 알아서 바로 이걸 하는게 낫다고 생각했다. 혹시 나중에 배울 일이 생기면 그때 봐야겠다.

# Three.js란?

WebGL을 사용해봤으면 알겠지만, WebGL로 뭔가를 렌더링 하려면 엄청난 양의 코드가 필요하다. 특히 3D라면 더더욱 어렵고 복잡하다. 그래서 WebGL로 좀 더 쉽게 3D렌더링을 할 수 있도록 Three.js, Scene.js같은 라이브러리들이 등장했다.

Three.js에선 Scene위에 객체들을 올리고, Camera를 통해 화면을 어떻게 렌더링할지 정한 후, Renderer가 Scene과 Camera정보를 이용해 3D씬을 렌더링하는 방식으로 작동한다.

Three.js의 구조를 잘 설명한 사진이 있어서 가져와봤다.![threejs-structure](/assets/images/threejs-structure-1617348158847.svg)

<div style="font-size=14px; width=95%;">(출처: https://threejsfundamentals.org/threejs/lessons/kr/threejs-fundamentals.html)</div>

# Three.js 시작

three.js를 시작하려면 일단 프로젝트에 three.js파일을 추가해야 한다. .js파일을 만들어 두고, 아래 링크의 코드를 복사한다음 붙여넣으면 된다.

<https://threejs.org/build/three.js>

그 후 아래와 같이 body태그에 포함시킨다.

```html
<body>
  <script src="js/three.js"></script>
</body>
```

이제 Three.js를 사용해보면 된다.

나는 Three.js를 처음 사용할 때, 정육면체를 먼저 그려봤다.

1. 먼저, canvas를 html요소에 포함한다. canvas를 만들지 않아도 자동으로 canvas를 생성해주지만, 어차피 나중에 만들어야 하니 미리 만들어 놓자.

   ```html
   <body>
     <canvas id="c"></canvas>
     <script src="js/three.js"></script>
     <script>
       //이 부분에 코드 작성 시작
     </script>
   </body>
   ```

   코드를 짜는 방법은 html파일에 script태그로 넣든 따로 js파일을 만들든 상관없다.

2. 만들어놓은 canvas를 불러오고, Three.js의 핵심이 되는 renderer를 canvas위에 생성한다.

   ```javascript
   const canvas = document.querySelector("#c");
   const renderer = new THREE.WebGLRenderer({ canvas });
   ```

   여기서 THREE가 전부 대문자인걸 주의하자. 나는 Three라고 써서 엄청 시간을 잡아먹었다..

3. 다음으로 Camera를 만들어보자.

   ```javascript
   const camera = new THREE.PerspectiveCamera(
     75,
     window.innerWidth / window.innerHeight,
     0.1,
     5
   );
   camera.position.z = 2; //카메라 위치 이동, default로 아래쪽 바라봄.
   ```

   Threejs에는 몇가지 카메라가 있는데, 여기서는 PerspectiveCamera를 사용했다. PerspectiveCamera의 인자는 차례대로 field of view(시야각), aspect, near, far이다.

   - field of view(시야각): 말 그대로 볼 수 있는 각도.
   - aspect: canvas의 크기 비율, canvas크기를 따로 설정하지 않으면 2가 기본값이다.
   - near, far: 랜더링 범위를 near~far로 제한

   ![KakaoTalk_20210402_164956574](/assets/images/KakaoTalk_20210402_164956574.jpg)

4. 다음으로는 Scene을 만들자.

   ```javascript
   const scene = new THREE.Scene();
   ```

   이제 필수적으로 필요한 것들은 다 만들었다. 다음으로 정육면체를 만들어서 Scene에 추가하면 된다.

   간단하게 기하 객체를 만드는 법을 소개하자면, Geometry 객체와 Material 객체를 생성한 후, 이 둘을 포함한 Mesh객체를 만들어주면 된다.

5. 그럼 먼저 Geometry(형태)를 만들어보자.

   ```javascript
   const geometry = new THREE.BoxGeometry();
   ```

   이 BoxGeometry가 정육면체의 Geometry이다.인자로 순서대로 boxWidth, boxHeight, boxDepth를 정해줄 수 있지만, 정해주지 않으면 기본적으로 1로 된다.

6. 다음으로 Material을 만들자.

   ```javascript
   const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
   ```

   color외에 image를 줄 수도 있고 밝기를 줄 수도 있는데 일단은 color만 줬다.

7. 이제 Mesh를 만들고 Scene에 추가하자.

   ```javascript
   const mesh = new THREE.Mesh(geometry, material);
   scene.add(mesh);

   renderer.render(scene, camera);
   ```

여기까지 하고 실행해보면 내가 만든게 이게 맞나.. 싶은 끔찍한 사각형이 보일거다.

![화면 캡처 2021-04-02 171405](/assets/images/화면 캡처 2021-04-02 171405.png)

입체적으로 보이지 않는 이유는 카메라가 한면만 보고 있기 때문이다. 정사각형이 아닌게 보일 수도 있는데, 아까 camera를 만들때, canvas크기 비율이 아닌 화면 크기 비율을 줘서 그렇다.

이제 정육면체의 모든 면을 볼 수 있게, 그리고 canvas 크기를 화면에 맞게 만들어보자.

8. 먼저 canvas크기를 맞춰보자. css로 html, body의 margin을 없애고, height:100%를 준다. 그 후

   ```javascript
   renderer.setSize(window.innerWidth, window.innerHeight);
   ```

   이 코드를 const renderer을 선언한 부분 다음 줄에 집어넣자. 이제 새로고침하면 화면 크기에 딱 맞는 canvas가 된다.

   화면 size가 변했을 때 canvas크기가 변하지 않아 되게 불편한데, 이건 마지막에 고쳐보자.

9. 이제 정육면체의 모든 면을 보기 위해 회전 시켜보자.

   ```javascript
   function render(time) {
     time *= 0.001;

     mesh.rotation.x = time;
     mesh.rotation.y = time;

     renderer.render(scene, camera);
     requestAnimationFrame(render);
   }
   requestAnimationFrame(render);
   ```

   위 코드를 renderer.render(scene, camera)가 있던 부분을 지우고 추가한다. 여러 방법이 있는데, time을 쓰는 방법을 사용했다. mesh.rotation.x, y의 값을 적당히 잘 바꿔주기만 하면 된다.

   requestAnimationFrame은 디스플레이 주사율에 맞춰 함수를 반복적으로 실행해주는데, setInterval함수와 비슷하지만 화면을 떠났을 때 자동으로 멈춰주는 기능이 있어 훨씬 좋다.

   이제 실행해보면 정육면체가 빙글 돌고있을 것이다.

   여기서 끝내도 나쁘지 않지만, 광원을 추가하고, 화면 사이즈 조절까지 해보겠다.

10. 광원추가

    ```javascript
    {
      const color = 0xffffff;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(-1, 2, 4); //광원 위치 설정
      scene.add(light); //Scene에 추가
    }
    ```

    이제 아까 const material = new THREE.MeshBasicMaterial({color: 0x00ff00}); 을 선언한 곳에서 MeshBasicMaterial을 MeshPhongMaterial으로 바꿔주면 그림자가 적용된다.

11. 화면 resize

    ```javascript
    window.addEventListener("resize", resize, false);

    function resize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5
      );
      camera.position.z = 2;
    }
    ```

    코드 첫부분에 위 코드를 추가하고, const camera를 선언했던 부분의 const를 let으로 바꿔주면 된다.

이제 진짜 정사각형이 잘 굴러가는게 보인다.

![ezgif.com-gif-maker](/assets/images/ezgif.com-gif-maker.gif)

아래는 완성된 코드다.

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			html, body{
				margin: 0;
				height: 100%;
			}
		</style>

	</head>
	<body>
		<canvas id="c"></canvas>

		<script src="./three.js"></script>
		<script>
			window.addEventListener('resize', resize, false);

			function resize(){
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5);
				camera.position.z = 2;
			}

			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({canvas});
			renderer.setSize( window.innerWidth, window.innerHeight );

			let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5);
			camera.position.z = 2; //카메라 위치 이동, default로 아래쪽 바라봄.

			const scene = new THREE.Scene();

			const geometry = new THREE.BoxGeometry();

			const material = new THREE.MeshPhongMaterial({color: 0x00ff00});

			const mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);

			{
				const color = 0xFFFFFF;
				const intensity = 1;
				const light = new THREE.DirectionalLight(color, intensity);
				light.position.set(-1, 2, 4);
				scene.add(light);
			}

			function render(time) {
				time *= 0.001;  // convert time to seconds

				mesh.rotation.x = time;
				mesh.rotation.y = time;

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}
			requestAnimationFrame(render);

		</script>
	</body>
</html>
```
