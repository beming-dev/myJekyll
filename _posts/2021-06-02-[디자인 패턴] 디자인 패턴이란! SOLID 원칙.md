# 배경

이번에 Flutter를 공부하게 되었는데, Flutter에서는 Dart언어를 사용한다. Dart언어가 객체지향이기도 하고, 이번에 Flutter로 만드는 앱도 좀 제대로 만들어볼 생각이어서 깔끔한 코드 작성을 위해 디자인 패턴에 대해 조금씩 정리해보려 한다. 

<br/>

<br/>

# 디자인 패턴이란?

객체 지향 프로그래밍을 설계 할 때, 자주 발생하는 문제를 해결하기 위해 사용되는 패턴이다.

프로젝트가 커지면 유지 보수가 어려워지는 점을 막기 위해 고안됐다. 

객체의 응집도는 높이고, 결합도는 낮추는 방향을 지향하는데, 여기서 응집도란 각 모듈이 고유의 기능을 잘 처리할 수 있는 정도를 나타내고, 결합도란 다른 모듈과 얼마나 의존성이 있는지를 나타낸다. 즉, "수정을 할 때 하나의 객체만 수정돼야 하고, 그 변경이 다른 객체에 영향을 주지 않도록 하는 것을 지향한다." 정도로 해석할 수 있을 것 같다.

<br/>

<br/>

# SOLID 원칙

객체지향에서 5대 원칙이라 불리는 SOLID원칙이 있는데, 디자인 패턴은 이 SOLID원칙에 입각해서 만들어졌다.

<br/>

<br/>

## 1. SPR (단일책임 원칙: Single Responsibility Principle)

- 클래스, 함수는 단 하나의 책임을 가져야 하며, 어떤 클래스를 변경하는 이유는 오직 하나여야 한다.

<br/>

<br/>

## 2. OCP (개방폐쇄의 원칙: Open Close Principle)

- 컴포는트, 클래스, 모듈, 함수 등의 요스는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
- 즉, 요소들은 수정이 필요할 때 소스 코드를 수정하지 않고 재사용해서 확장할 수 있도록 설계해야 한다는 것이다.

<br/>

<br/>

## 3.  LSP (리스코브 치환의 원칙: The Liskov Substitution Princliple)

- 자식(상속된)  클래스는 최소한 자신 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.

영문 위키피디아에는  "Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it" 이라고 소개돼있는데, 직역하면 ""베이스 클래스의 포인터나 참조형을 사용하는 함수는 파생된 클래스의 object를 몰라도 사용할 수 있어야 한다."인데, 처음엔 잘 이해가 안갔지만 잘 생각해보니 같은 말이다.

<br/>

<br/>

## 4. ISP (인터페이스 분리의 법칙: Interface Segregation Principle)

- 여러개의 한가지 목적을 가진 인터페이스가 하나의 여러 목적을 가진 인터페이스보다 낫다. 

위에는 영문 위키피디아 번역본인데, 다른 분들의 블로그를 보면 "한 클래스에 사용하지 않는 인터페이스는 구현하지 말아야 한다." 와 같이 설명돼있었다. 둘은 좀 다른 말 같은데 해석상 전자가 더 어울리는 것 같다.

<br/>

<br/>

## 5. DIP(의존성 역전의 원칙: Dependency Inversion Principle)

- 의존성이 생길 때, 구체적인 것이 아닌 추상적인 것에 의존해라.

구체적인 것: 클래스, 서브 클래스 인스턴스

추상적인 것: 추상 클래스, 인터페이스

이런식으로 디자인을 해야 하위 모듈의 변경이 상위 모듈의 변경을 요구하지 않는다고 한다. 

<br/>

<br/>



# 끝

디자인 패턴의 기본이 되는 SOLID 원칙에 대해 알아봤으니 앞으로 디자인패턴에 관한 내용을 하나씩 차례로 업로드 해야겠다.