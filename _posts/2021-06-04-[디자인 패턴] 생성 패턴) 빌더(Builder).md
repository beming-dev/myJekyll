---
layout: post
category: 디자인 패턴
thumbnail: design.png
tags: [desing pattern]
---

# 디자인 패턴 - 생성패턴

## 빌더(Builder)

<br/>

<br/>

### 사용이유

클래스를 만들 때 클래스 내부에 optional한 변수가 많아지면,  클래스를 생성할 때 사용하지 않는 변수에는 null값을 넘겨줘야 하고, 인자의 순서도 헷갈리는 문제가 발생한다. 

만약 노트북을 만든다고 생각해보자, 그러기 위해선 필수적으로 Ram, CPU, 디스플레이, 키보드 등등이 필요할것이다. 

그런데 선택적으로 필요한 옵션도 많이 존재한다. 예를들어 OS포함여부, ram확장 가능 여부, 지문 인식 등등 말이다.

그렇다면 이를 클래스로 만들기 위해 어떤 방법이 있을까? 

첫 번째로, 필수적으로 들어가야하는 요소들을 포함하는 클래스를 만들고, 옵션을 추가할 때마다 그 클래스를 상속받아서 새로운 클래스를 만드는 것이다. 그러나 이 방법은 optional한 변수가 많을때는 클래스가 엄청 많아질 것이므로 좋지 않다.

두 번째로, 모든 optional한 속성까지 변수로 포함한 클래스를 만드는 것이다. 이 방식도 생성자가 엄청 많아지거나 새로운 클래스를 생성할 때 new Laptop("16gb", "i7", "true", "true", null, null, ...)이런식으로 끔찍한 선언이 필요할 것이다.

빌더 패턴은 이런 문제를 해결하기 위해 등장했다. 이제 빌더 패턴의 예제를 보자.

<br/>

<br/>

### 예제

빌더 패턴에서는 클래스의 setter을 없애고 생성자를 private으로 선언한 후, 내부의 Builder 클래스를 통해 객체를 생성할 수 있도록 한다. 코드가 길지만 어려운 코드는 아니다.

```java
public class Laptop {
    //required parameters
    private String ram;
    private String cpu;
    private String display;
    
    //optional parameters
    private String os;
    private boolean isRamExpansionEnabled;
    
    //getter
    public String getRam(){
        return ram;
    }
    public String getCpu(){
        return cpu;
    }
    public String getDisplay(){
        return display;
    }
    public String getOs(){
        return os;
    }    
    public boolean getIsRamExpansionEnabled(){
        return isRamExpansionEnabled;
    }
    
    //constructor
    private Laptop(LaptopBuilder builder){
        this.ram = builder.ram;
        this.cpu = builder.cpu;
        this.display = builder.display;
        this.op = builder.os;
        this.isRamExpansionEnabled = builder.isRamExpansionEnabled;
    }
    
    public static class LaptopBuilder{
	//required parameters
        private String ram;
        private String cpu;
        private String display;

        //optional parameters
        private String os;
        private boolean isRamExpansionEnabled;

        public LaptopBuilder(String ram, String cpu, String display){
            this.ram = ram;
            this.cpu = cpu;
            this.display = display;
        }

        public LaptopBuilder setOs(String os){
            this.os = os;
            return this;
        }

        public LaptopBuilder setRamExpansionEnabled(boolean isRamExpansionEnabled){
            this.isRamExpansionEnabled = isRamExpansionEnabled;
            return this;
        }

        public Laptop build(){
            return new Laptop(this);
        }
    }
}
```

이제 이런식으로 빌더를 만들었을 때 어떤식으로 클래스를 만들 수 있을지 보자.

```java
public class Client{
    public static void main(String[] args){
        Laptop myLaptop = new Laptop.LaptopBuilder("15gb", "i7", "led")
            .setOS("macOS")
            .setRamExpansionEnabled(false)
            .build();
    }
}
```

필수 인자들을 넘겨서 Builder 클래스를 만들고 optional한 인자들은 원하는 것만 골라서 추가해줄 수 있다.

<br/>

<br/>

# 끝

빌더패턴은 추상 팩토리 패턴에 비해 훨씬 이해하기 편했고, 훨씬 잘 사용할 수 있을 것 같다. 