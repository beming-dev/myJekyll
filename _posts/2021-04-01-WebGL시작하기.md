---
layout: post
category: WebGL
thumbnail: WebGL.png
tags: [WebGL, three.js, html]
typora-copy-images-to: github blog\beming-dev.github.io\assets\images
typora-root-url: github blog\beming-dev.github.io
---

WebGL로 만든 3D모델들이 너무 멋있어서 나도 한번 배워보려고 했다. 다른 분의 WebGL포스트를 보며 따라하려고 했는데 웬걸.. 삼각형 하나 그리는데에 코드를 100줄 가까이 적었고, 이해하는 것도 너무 힘들었다. 이 얘길 친구한테 했더니 Three.js라는 더 쉽게 3D 모델링을 해주는 라이브러리를 알려주었다.

바로 three.js를 쓰는것도 좋지만 WebGL에 대해서도 한번 이해하고 Three.js를 쓰고 싶었다. 어차피 이해하는 데에 한참 걸릴 것 같아서 글로 정리하면서 공부하기로 했다. 좀 더 정확하고 자세한 내용을 보고 싶으면 아래 블로그를 추천한다.

[webglfundamentals](https://webglfundamentals.org/webgl/lessons/ko/)

# WebGL이란?

WebGL은 3차원 컴퓨터 그래픽스 API를 제공하는 웹 기반 그래픽 라이브러리이다. HTML canvas에 포함되어 있다.

webGL을 사용하면 웹에서 엄청나게 빠른 속도로 랜더링이 가능한데, 그래픽카드의 GPU를 이용한 하드웨어 랜더링을 하기 때문이다.

WebGL은 GPU에서 실행되기 때문에 GPU에서 실행되는 코드를 제공해야 한다. 이 코드는 크게 vertex shader, fragment shader라는 두개의 shader로 나뉘는데, 전자는 정점의 위치를 계산하는 역할, 후자는 각 픽셀에 대한 색상을 계산하는 역할을 한다.

WebGL을 사용해서 할 수 있는건 점, 선, 삼각형을 그리는 정도이기 때문에 복잡한 모델을 랜더링 하려면 엄청 복잡해진다. 그래서 이를 더 편하게 해주는 three.js같은 라이브러리가 존재한다.

# Shader

shader를 알기 전에 먼저 GLSL(OpenGL shading language)이라는 것을 알아야 한다. 그리고 GLSL을 알려면 OpenGL에 대해서도 알아야한다(...).

1. OpenGL은 그래픽스 표준 API규격이다. 컴퓨터화면에 무언가를 그리기 위해선 이 라이브러리를 사용해야 한다. WebGL은 이 OpenGL 표준을 사용해 javascript, canvas를 이용해 웹에서 사용할 수 있도록 만든 그래픽 라이브러리이다.
2. GLSL은 OpenGL shading language라는 이름 그대로 OpenGL의 shader를 컨트롤 하기 위한 언어이다. 뒤에서 나오는 vertex shader와 fragment shader를 이 GLSL로 짤것이다. 문법은 C와 비슷해서 크게 어렵지 않을 것이다.

### vertex shader

WebGL에서 좌표는 canvas크기에 상관없이 각 축에서 -1~1의 값을 가진다. 이를 clip space라고 하는데, vertex shader는 이 clip space 좌표를 생성하는 역할을 한다. 각 정점마다 한 번씩 호출된다.

vertex shader는 기본적으로 아래 형식을 취한다. gl_position이라는 특수한 변수에 clip space좌표를 넣어주면 GPU가 그 값을 꺼내다 쓰는 것이다. 추가로 shader에는 main함수가 꼭 존재해야 한다.

```
void main() {
  gl_Position = doMathToMakeClipspaceCoordinates
}
```

shader로 GPU에 데이터를 제공하는 방법으로는 4가지가 있는데, 일단은 Attribute & buffer에 대해 소개하겠다.

attribute & buffer 방식으로 데이터를 전달하기 위해서는 일단 buffer를 만들고 데이터를 전달해줘야 한다.

```glsl
attribute vec4 a_position;
void main() {
  gl_Position = a_position;
}
```

이렇게 shader를 작성한 후 buffer로 정점을 전달해주면

![vertex-shader-anim](/assets/images/vertex-shader-anim.gif)

위 gif처럼 동작한다.(출처: webglfundamentals.org)

### fragment shader

fragment shader는 현재 픽셀에 색상을 제공하는 역할을 한다. 각 픽셀마다 한번씩 호출된다.

기본적으로 아래와 같은 형식을 취하는데

```glsl
precision mediump float;

void main() {
  gl_FragColor = doMathToMakeAColor;
}
```

vertex shader와 비슷하게 main함수가 있고, gl_FragColor라는 특별한 변수에 값을 전달해주면 GPU가 읽는 식이다.

아래 코드는 모든 정점을 vec4(1, 0, 0.5, 1)에 해당하는 색으로 칠한다.

```glsl
precision mediump float; //중간 정밀도 사용

void main() {
  gl_FragColor = vec4(1, 0, 0.5, 1);
}
```

vec4로 색을 표현할 때는 값을 각각 rgba순으로 0~1사이의 값을 주면 된다.

# 삼각형 그리기

이제 실제로 WebGL을 사용해보자.

- 먼저 html에 canvas를 생성하고 id를 준다.

  ```html
  ...
  <canvas id="c" width="500px" height="500px"></canvas>
  ...
  ```

- js파일을 만들고 canvas가져오기

  ```javascript
  let canvas = document.querySelector("#c");

  let gl = canvas.getContext("webgl");
  if (!gl) {
    alert("no WebGL");
  }
  ```

  이 때, 당연히 html의 body태그 끝나기 전에 script를 호출해서 연결해야 한다.

- vertex shader, fragment shader GLSL로 입력

  ```
  const vertexShaderSource = `
  attribute vec4 a_position;
  void main() {
    gl_Position = a_position;
  }
  `

  const fragmentShaderSource = `
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1, 0, 0.5, 1); // 붉은 보라색 반환
  }
  `
  ```

  shader를 script태그로 감싼서 만든다음 js코드에서 queryselector로 가져올 수도 있지만, 여기서는 그냥 문자열 변수로 선언했다.

- shader를 컴파일하기 위한 함수 작성

  ```javascript
  function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
      return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
  }
  ```

  WebGL의 함수를 사용해 shader를 gl변수에 등록하는 함수이다.

- 이제 아래와 같이 함수를 호출하면 shader가 컴파일 됩니다.

  ```javascript
  let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  let fragmentShader = createShader(
    gl,
    gl.FRAGMENT_SHADER,
    fragmentShaderSource
  );
  ```

- 다음으로는 두 shader를 link하는 과정이다.

  ```javascript
  function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    let success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
      return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
  }

  //호출
  let program = createProgram(gl, vertexShader, fragmentShader);
  ```

- GPU에 attribute & buffer 방식으로 데이터를 전송하기 위해, attribute의 위치를 찾고 buffer를 생성해야 한다.

  ```javascript
  //attribute 위치 찾기
  let positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  //buffer생성
  let positionBuffer = gl.createBuffer();
  ```

- position buffer를 할당하기

  ```javascript
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  ```

  이 과정을 거치면 bind point라는 곳에 position buffer가 들어가는데, 그럼 WebGL을 통해 이 자원들을 관리할 수 있게 된다.

- 드디어 buffer에 데이터를 넣는 과정이다.

  ```javascript
  let positions = [0, 0, 0, 0.5, 0.7, 0];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  ```

여기까지가 삼각형을 그리기 위해 준비해야 할 것들이다. 당연히 아직 랜더링을 하지 않았기 때문에 이렇게 코드를 짜고 실행해도 화면에 삼각형은 표시되지 않는다. 후...... 이제 남은 랜더링을 마저 해보자.

- 먼저 WebGL에게 canvas의 크기를 알려줘서 clip space와 screen의 크기 변환에 참고할 수 있도록 해야한다.

  ```
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  ```

- 다음으로 아까 만들어둔 program 변수를 WebGL에게 사용할 거라고 알려준다.

  ```
  gl.useProgram(program);
  ```

- 이제 아까 찾아둔 attribute주소로 attribute를 활성화하고, 데이터를 어떻게 읽어야 되는지 WebGL에게 알려주면 끝이다.

  ```javascript
  //attribute 활성화
  gl.enableVertexAttribArray(positionAttributeLocation);

  let size = 2; // 반복마다 2개의 컴포넌트
  let type = gl.FLOAT; // 데이터는 32bit 부동 소수점
  let normalize = false; // 데이터 정규화 안 함
  let stride = 0; // 0 = 다음 위치를 얻기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
  let offset = 0; // Buffer의 처음부터 시작
  gl.vertexAttribPointer(
    positionAttributeLocation,
    size,
    type,
    normalize,
    stride,
    offset
  );

  let primitiveType = gl.TRIANGLES;
  let count = 3;
  gl.drawArrays(primitiveType, offset, count);
  ```

이렇게 거의 100줄에 달하는 삼각형을 그리는 코드가 작성되었다. 코드 내용은 위에서 소개한 블로그의 내용과 거의 비슷하지만 내가 따라하면서 조금 힘들었어서 다시 정리해봤다. 이제 실행하면 아래처럼 보일 것이다.(배경색은 css로 바꿨다.)

![화면 캡처 2021-04-01 165356](/assets/images/화면 캡처 2021-04-01 165356.png)

사실 내가 앞으로 WebGL을 쓸 일은 딱히 없을 것 같긴한데 예쁜것도 한번 만들어보고 싶고, 배워두면 혼자 놀때 심심할 것 같진 않아서 앞으로 좀 열심히 공부해보려 한다.

위에서 얘기했듯 순수WebGL로 뭔가를 만들기는 정말 어렵다. 그래서 나도 WebGL로 정육면체 까지만 그려보고 three.js를 공부할거다. 사실 이미 한번 써봤는데 약간 unity느낌도 나고 훨씬 편하다 훨씬...

아래는 완성 파일이다.

index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <canvas id="c" width="500px" height="500px"></canvas>

    <script>
      let canvas = document.querySelector("#c");

      let gl = canvas.getContext("webgl");
      if (!gl) {
        alert("no WebGL");
      }

      const vertexShaderSource = `
        attribute vec4 a_position;
        void main() {
        gl_Position = a_position;
        }
        `;

      const fragmentShaderSource = `
        precision mediump float;
        
        void main() {
        gl_FragColor = vec4(1, 0, 0.5, 1); // 붉은 보라색 반환
        }
        `;

      function createShader(gl, type, source) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }

        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      }

      let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      let fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );

      function createProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        let success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      }

      //호출
      let program = createProgram(gl, vertexShader, fragmentShader);

      //attribute 위치 찾기
      let positionAttributeLocation = gl.getAttribLocation(
        program,
        "a_position"
      );
      //buffer생성
      let positionBuffer = gl.createBuffer();

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      let positions = [0, 0, 0, 0.5, 0.7, 0];
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      );

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      gl.useProgram(program);

      //attribute 활성화
      gl.enableVertexAttribArray(positionAttributeLocation);

      let size = 2; // 반복마다 2개의 컴포넌트
      let type = gl.FLOAT; // 데이터는 32bit 부동 소수점
      let normalize = false; // 데이터 정규화 안 함
      let stride = 0; // 0 = 다음 위치를 얻기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
      let offset = 0; // Buffer의 처음부터 시작
      gl.vertexAttribPointer(
        positionAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      );

      let primitiveType = gl.TRIANGLES;
      let count = 3;
      gl.drawArrays(primitiveType, offset, count);
    </script>
  </body>
</html>
```
